
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - octree</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script type="text/javascript" src="js/three.min.js"></script>
		<script type="text/javascript" src="js/Octree.js"></script>
		<script>

			var camera,
				scene,
				renderer,
				octree,
				geometry,
				material,
				mesh,
				meshes = [],
				radius = 500,
				radiusMax = radius * 10,
				radiusMaxHalf = radiusMax * 0.5,
				radiusSearch = 400,
				base = new THREE.Color( 0xff00ff )

			init();
			animate();

			function init() {

				// standard three scene, camera, renderer

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, radius * 100 );
				scene.add( camera );

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// create octree

				octree = new THREE.Octree( {
					// when undeferred = true, objects are inserted immediately
					// instead of being deferred until next octree.update() call
					// this may decrease performance as it forces a matrix update
					undeferred: true,
					// set the max depth of tree
					depthMax: Infinity,
					// max number of objects before nodes split or merge
					objectsThreshold: 8,
					// percent between 0 and 1 that nodes will overlap each other
					// helps insert objects that lie over more than one node
					overlapPct: 0.0,
					// pass the scene to visualize the octree
					scene: scene
				} );

        // build octree

        buildOctree();

				// info

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '0';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.style.padding = '10px';
				info.style.background = '#FFFFFF';
				info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> webgl - octree (sparse & dynamic) - by <a href="http://github.com/collinhover/threeoctree" target="_blank">collinhover</a>';
				document.body.appendChild( info );

			}

			function animate() {

				// note: three.js includes requestAnimationFrame shim
				requestAnimationFrame( animate );

				// render results

				render();

				// update octree to add deferred objects

				octree.update();

			}

			var geometry = new THREE.BoxGeometry( 50, 50, 50 );

			function buildOctree() {

        // create new object

        for (var counter = 0; counter <= 1000; counter++) {

          mesh = new THREE.Line( geometry, new THREE.MeshBasicMaterial( { color: new THREE.Color( base ) } ) );

          // give new object a random position in radius

          mesh.position.set(
            Math.random() * radiusMax - radiusMaxHalf,
            0,
            Math.random() * radiusMax - radiusMaxHalf
          );

          // add new object to octree and scene

          octree.add( mesh );
          scene.add( mesh );

          // store object for later

          meshes.push( mesh );

        }

			}

			function render() {

				var timer = - Date.now() / 5000;

				camera.position.x = Math.cos( timer ) * 10000;
				camera.position.z = Math.sin( timer ) * 10000;
				camera.position.y = 5000;
				camera.lookAt( scene.position );

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
